# Документация по AUTH.module
## signup. Как создать пользователя/зарегистрироваться
На вход принимаем AuthDTO. Там лежит обычно login, password.
password хешируем при помощи argon2
Для начала надо внести данные в базу данных в стиле:
    * login,
    * hash, //(argon2.hash(password))
    * groupid, //id группы в которой он состоит
    * campid, //id его лагеря
    * role, // более подробно стоит глянуть в db, там прописаны роли. 32 это пользователь
    * permissions //права побитовые доступа. подробнее глянуть в db. права считаются наложением маски прав поверх прав(например у пользователя есть право читать(1) и переписывать(2) свои данные, то получается что итоговые его права это 3(1+2))
После занесения данных, наш пользователь считается активным. 

Что должны вернуть: 'Вы авторизованы'. Ваш токен: *результат функции signToken*
Что возращаем: информацию о нем, которую мы создали(постфактум надо заменить на что-то более нейтральное)

## signin. Как входить в систему и получать bearer token(JWT)
На вход принимаем AuthDTO. Там лежит обычно login, password.
ищем пользователя по логину в базе данных, если находим, то проверяем правильность пароля и идем выдавать токен в signToken. На текущий момент в неё передается данные:
    * userId,
    * "auth.service: signToken",
    * 999999
В signToken нужно передавать адекватные данные, в том числе и имя мастер токена и права, с которыми мы даем токен

Что возвращаем: результат функции signToken

## signToken. Подписываем данные и получаем JWT
На вход принимаем:
    * userid,           //userid на имя которого мы подписываем JWT
    * tokenName,        //имя мастертокена, которым мы можем авторизоваться
    * tokenPermissions  //права токена. Это то, что накладывается побитово на права пользователя user.permissions & tokenPermissions. Нужно для контроля и выдачи токенов, к примеру можно привести как реализовано это в ВК

Ищем мастертокен с именем tokenName в таблице БД ActiveToken.
Если вдруг такового нет, то создаем в функции createActiveToken. Функция принимает как параметры:
    * userid,
    * tokenName,
    * tokenPermissions.
И возвращает экземпляр ActiveToken.

В переменной token лежит токен из БД ActiveToken

Ложим все в payload:
    * sub: userid,
    * token: token,
    * v: 1      //версия токена. Требуется, чтобы определить, каким токеном мы пользуемся. Задел на будующее

Дальше подписываем payload ключом JWT_SECRET и получаем JWT token.

Что возвращаем: {
        access_token: JWT token
    }

## createActiveToken. Функция для создания мастер токенов
На вход принимает:
    * userid,           //userid на имя которого мы подписываем JWT
    * tokenName,        //имя мастертокена, которым мы можем авторизоваться
    * tokenPermissions  //права токена. Это то, что накладывается побитово на права пользователя user.permissions & tokenPermissions. Нужно для контроля и выдачи токенов, к примеру можно привести как реализовано это в ВК

создаем токен(случайное 20-ти значное число) в кодировке base64url
готовим payload для загрузки в бд и просто создаем ешё одну ячейку в БД ActiveToken

Что возвращаем: экземпляр ActiveToken